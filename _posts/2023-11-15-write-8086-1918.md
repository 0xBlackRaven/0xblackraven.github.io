---
layout: post
title: RF Surveillance
subtitle: Write-Up pour le NBCTF
tags: [writeup, misc, nbctf, rf]
comments: true
---
Bonjour ! Voici mon write-up pour le challenge `RF Surveillance` à l'occasion du NoBracket CTF. Il s'agit de mon deuxième write-up, alors n'hésitez pas à aller jeter un coup d'oeil au premier !
Alors tout d'abord, je tenais à remercier `Endeavxor` pour son challenge qui m'a particulièrement plu. Mais sur ce, passons au write-up ! 

## Premier coup d'oeil
![Chall](https://cdn.discordapp.com/attachments/822188888297963560/1175095822724108419/Capture_decran_28.png?ex=6569fc44&is=65578744&hm=495b544beb01cdd37c9cb371abca46257800538154b9117ad3df6f1d922e37d1&){: .mx-auto.d-block :}
Ce challenge est accompagné de deux ressources. La configuration de l'émetteur sur GNU Radio, puis la configuration du récepteur.
Regardons tout d'abord le flowgraph de l'émetteur :

![emetteur](https://cdn.discordapp.com/attachments/822188888297963560/1175096364762419210/EMISSION_GNU_Radio.png?ex=6569fcc5&is=655787c5&hm=84cf46f5e25c3b6fab9ece1495dfd034c963865cde6b30cbb40824902a12b530&){: .mx-auto.d-block :}

Nous avons pas mal de choses intéressantes ici. Nous voyons qu'un fichier intitulé `message_to_transmit.wav` est passé à travers un bloc `NBFM Transmit`. En gros, ce bloc produit une sortie en bande de base complexe modulée en FM. Encore un peu trop barbare. Pour faire simple, ça ![module](https://fr.wikipedia.org/wiki/Modulation_du_signal) juste le signal en FM. Les paramètres ne nous intéressent pas trop ici.
Le bloc `Rational Resampler` ne nous intéresse pas non plus. Mais par contre, le `PlutoSDR Sink` nous intéresse fortement. Nous allons ici nous intéresser surtout au Sample Rate, qui nous servira plus tard.
Donc résumons : nous avons un signal modulé en FM, donc la fréquence d'échantillonage est égale à `132300 Hz`. Nous pourrions déjà regarder sur Audacity, mais regardons le flowgraph du receveur.

![receveur](https://cdn.discordapp.com/attachments/822188888297963560/1175096365303468092/RECEPTION_GNU_Radio.png?ex=6569fcc5&is=655787c5&hm=5e3dabd33f11240002894450c68d9932d231978437f8f847087e76562bed5c26&){: .mx-auto.d-block :}

Bon, rien de très utile ici.

Passons maintenant à Audacity ! Mais pourquoi Audacity ? Tout simplement parce que :
1. Je préfère le nom
2. C'est plus simple et compréhensible (même pour vous, ce sera beaucoup plus plaisant car je ne devrais pas m'attarder à expliquer des modules mathématiques que moi-même je ne comprends pas)


![meme](https://cdn.discordapp.com/attachments/822188888297963560/1175101705495523328/86e0w3.gif?ex=656a01be&is=65578cbe&hm=861e8d44c9d92a70e7c2955d17672f32632ad909a1379d37b1b9553c1aaeda42&){: .mx-auto.d-block :}

## Retrouver un signal compréhensible
On lance donc Audacity, puis on va dans `Fichier -> Ouvrir...` puis on choisit notre `signal_saved`. Et puis là, erreur !

{: .box-error}
Ça ne marche pas... Eh bien, c'est parce que notre fichier est un fichier signal brut ! C'est par ailleurs ce que nous dit Audacity, qui pour le coup ne peut pas être plus clair sur ce qu'il faut faire.

On va donc dans `Fichier -> Importer -> Données brutes`, on sélectionne notre fichier. On clique ensuite sur `Détecter`, ce qui nous évite de faire des réglages sur l'encodage. Dernier réglage : on change la fréquence d'échantillonage vers `132300 Hz`. Et puis on est bon !
On importe... Et on run. Nous avons du morse ! Mais, vu la taille, ça risque d'être très long de décoder ce message. On va donc le scripter ! Même si je n'aime pas trop programmer, je n'avais vraiment pas la foi de tout décoder à la main
